> [!CAUTION]
> This Rust crate is potentially dangerous so there is a chance it will cause harm to you or your computer. Run at you own risk (ideally in a sandbox), and always audit the code generated by it.

# ai bindgen

This is a procedural macro that generates Rust code at compile-time using the OpenAI (or compatible) API. Simply add the dependency to your `Cargo.toml` and follow the example usage.

```toml
[dependencies]
ai_bindgen = { git = "https://github.com/germangb/ai-bindgen-rs.git" }
```

## Example usage

You must have a valid API token and define the following two variables in your environment, so the macro can connect to the OpenAI API, and select a model of your choosing:

```bash
export OPENAI_API_KEY="<your-api-token>"
export OPENAI_API_MODEL="gpt-5"
```

> [!NOTE]
> By default the macro will send requests  to `https://api.openai.com/v1/` endpoint. You can override this with the `OPENAI_API_URL` environment variable.

The macro must be added to the top of an `extern` block, and the functions within, like this:

```rust
use ai_bindgen::ai;

#[ai]
extern "C" {
    #[ai(prompt = "return the n-th prime number, please")]
    fn prime(n: i32) -> i32;

    // no prompt parameter (the signature should be self explanatory :)
    #[ai]
    fn max(a: i32, b: i32) -> i32;
}

fn main() {
    println!("The 15th prime number is {}", prime(15)); // 47 (hopefully)
    println!("max(4, 6) = {}", max(4, 6)); // 6
}
```

(Refer to the [`parameters.rs`](examples/parameters.rs) example for a list of supported parameters)

> [!TIP]
> You can run `cargo expand` to get an idea of what the compiler will generate. This is what it came up with for me when I ran it last time:
>
> ```rust
> #![feature(prelude_import)]
> #[prelude_import]
> use std::prelude::rust_2024::*;
> #[macro_use]
> extern crate std;
> use ai_bindgen::ai;
> #[allow(warnings)]
> fn prime(n: i32) -> i32 {
>     if n <= 0 {
>         return 0;
>     }
>     let target = n as usize;
>     let mut primes: Vec<i32> = Vec::with_capacity(target);
>     let mut candidate: i32 = 2;
>     while primes.len() < target {
>         let mut is_prime = true;
>         let cand64 = candidate as i64;
>         for &p in primes.iter() {
>             let p64 = p as i64;
>             if p64 * p64 > cand64 {
>                 break;
>             }
>             if candidate % p == 0 {
>                 is_prime = false;
>                 break;
>             }
>         }
>         if is_prime {
>             primes.push(candidate);
>         }
>         if candidate == 2 {
>             candidate = 3;
>         } else {
>             if candidate >= i32::MAX - 2 {
>                 break;
>             }
>             candidate += 2;
>         }
>     }
>     if primes.len() == target { primes[target - 1] } else { 0 }
> }
> #[allow(warnings)]
> fn max(a: i32, b: i32) -> i32 {
>     if a >= b { a } else { b }
> }
> fn main() {
>     {
>         ::std::io::_print(format_args!("The 15th prime number is {0}\n", prime(15)));
>     };
>     {
>         ::std::io::_print(format_args!("max(4, 6) = {0}\n", max(4, 6)));
>     };
> }
> ```